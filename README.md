# High-Level Approach:
This project was a tricky one since we had not worked with routers in the past. However, the lectures went hand in hand with the project and provided a general overview of how routers work and how they are applied to everyday life. It was crucial that we understood how routers work and how the tests are written in the project folder. We analyzed the tests and instructions to determine what our router will look like, what kind of messages it will receive and send back, as well as deciding how our forwarding table is going to work and adjust itself with every new packet that comes in. The three main tasks that our router took on were as follows:
1) Accepting route update and withdraw messages from the BGP neighbors and forwarding updates as appropriate
2) Forwarding data packets to the correct destination (filtering through the destinations is there were multiple possible ones)
3) Returning error messages in cases where a data packet cannot be delivered
4) Coalescing forwarding table entries for networks that are adjacent and on the same port
5) Serializing our routing table cache so that it can be checked for correctness

# Challenges Faced:
Many challenges were faced and overcome in this project. A lot of the mathematic functions where we had to convert an IP address to cidr were confusing to implement over Python, although it is simple enough in your head or with a calculator. Determining when to make something a global variable compared to a local variable was something that took time to wrap our heads around. Getting data to deliver to the next best hop/route was definitely one of the harder challenges we faced. To choose the entry from our forwarding table with the longest prefix, and if we still have more, then by the localPrefs, then by the selfOrigins, ... and so forth, involved a lot of recurring through the forwarding table and updating our current array of possible destinations, so finding an efficient way to do that involved a little bit of a debate.

# Properties/Features of Design that is Good:
We believe the design and structure of our code is readable. We left a sufficient but not overwhelming amount of comments, so that we ourselves can understand and hopefully people reading it will be able to understand. We used a decent amount of helpers to break up tasks and to abstract some tasks and not repeat code. We tried to create code that uses less space and time. Updating the forwarding table especially requires a lot of loops, and we did not want to use more than we had to, or overcomplicate just to get the code working. We kept some jobs together, such as adding an entry to the forwarding table while aggregating, because it just made sense. They shouldn't be considered two different tasks. It's almost like removing stems from leaves before adding them into the salad, one natural motion.

# Overview of Testing:
The starter code for this project was sparse. Therefore, we would try to nail down test by test in increasing level of difficulty, since the next test would piggy-back off the one before. There was a lot of trial and error, and printing console statements, to really understand what our messages would be comprised of. It was helpful to receive status messages from the simulator, which comes with a suite of configuration files in the directory configs/ that define situations our router must be able to handle. There was a lot of writing out algorithms on paper, looking into Python documentation for syntax, and writing comments to help us along the process.